// Copy this into shadertoy.com
// Set iChannel0 to "Soundcloud" or any audio input for beat sync

// HSV to RGB conversion
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

// Attractor functions
float f(float x, float u) {
    return u * x + 2.0 * (1.0 - u) * x * x / (1.0 + x * x);
}

vec2 iterate(vec2 p, float u, float a, float b) {
    float x = p.x;
    float y = p.y;
    float nx = y + (1.0 - b * y * y) * a * y + f(x, u);
    float ny = f(nx, u) - x;
    return vec2(nx, ny);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);
    
    // Get audio data from iChannel0
    float bass = 0.0;
    float beatIntensity = 0.0;
    
    // Sample low frequencies for bass
    for(int i = 0; i < 8; i++) {
        bass += texture(iChannel0, vec2(float(i) / 512.0, 0.25)).x;
    }
    bass /= 8.0;
    
    // Beat detection - sample very low freq for kick
    for(int i = 0; i < 5; i++) {
        beatIntensity += texture(iChannel0, vec2(float(i) / 512.0, 0.25)).x;
    }
    beatIntensity /= 5.0;
    
    // Quantize time to beats - only advance on strong bass hits
    float beatThreshold = 0.6;
    float beatCount = floor(iTime * 2.0 + beatIntensity * 10.0 * step(beatThreshold, beatIntensity));
    float t = beatCount * 0.15;
    
    // Parameters
    float a = 0.003;
    float b = 0.06;
    float u = -0.8 + bass * 0.3;
    
    vec3 col = vec3(0.0);
    
    // Draw multiple points
    for (int s = 0; s < 50; s++) {
        vec2 p = vec2(1.0, 1.0);
        
        // Iterate the attractor
        for (int i = 0; i < 800; i++) {
            p = iterate(p, u, a, b);
            
            float c = t - length(p) / 4.0;
            vec2 pos = vec2(
                p.y * (5.0 * sin(c) + 11.0) * 0.05,
                p.x * (2.0 * cos(c) + 7.0) * 0.05 + 0.09 * sin(p.y / 4.0 + t)
            );
            
            float dist = length(uv - pos);
            
            if (dist < 0.008) {
                // Rainbow color based on position and iteration
                float hue = fract(float(i) * 0.002 + length(p) * 0.1 + t * 0.1);
                float sat = 0.7 + 0.3 * bass;
                float val = 0.8 + 0.2 * bass;
                
                vec3 rainbowCol = hsv2rgb(vec3(hue, sat, val));
                float intensity = 1.0 - smoothstep(0.0, 0.008, dist);
                col += rainbowCol * intensity * 0.3;
            }
        }
    }
    
    fragColor = vec4(col, 1.0);
}