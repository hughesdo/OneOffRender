#version 330 core

// "SDF Bloom Tapestry" â€” layered soft-min shapes breathing in polar symmetry
// Influences: Fabrice (smooth disk logic), BigWings (soft-min SDF layering), Ferris (light/color feel),
// plus nods to Evvvvil, Flopine, Nusan for field craft.

uniform float iTime;
uniform vec2 iResolution;
uniform sampler2D iChannel0;  // Audio texture

out vec4 fragColor;

// ===== TWEAKABLE VARIABLES =====
#define LAYERS 24
#define BRIGHTNESS 2.0
#define AUDIO_BRIGHTNESS 1.2
#define COLOR_BASE vec3(0.05,0.02,0.08)
#define COLOR_AMP vec3(0.9,1.1,1.3)
#define AUDIO_COLOR_SHIFT vec3(0.4,0.3,0.5)
#define BLOOM_STRENGTH 1.2
#define FRINGE_STRENGTH 0.9
#define AUDIO_BLOOM 0.9
#define AUDIO_FRINGE 0.6
#define SPEC_STRENGTH 0.18
#define SPEC_COLOR vec3(0.8,0.9,1.2)
#define AUDIO_SPEC 0.6
#define DARK_CRUSH 0.06
#define CONTRAST_GAMMA 3.8
// ===============================

float sat2(float x){ return clamp(x,0.0,1.0); }

vec2 rot2d(vec2 p, float a){ 
    float c=cos(a), s=sin(a); 
    return mat2(c,-s,s,c)*p; 
}

float sdCircle(vec2 p, float r){ 
    return length(p)-r; 
}

float sdRoundedBox(vec2 p, vec2 b, float r){
    vec2 q = abs(p)-b;
    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;
}

float sminExp(float a, float b, float k){
    // Exponential smooth min (bounded and stable)
    float ea = exp(-k*a), eb = exp(-k*b);
    return -(log(ea+eb))/k;
}

vec3 palette(float t, float audioShift){
    vec3 baseHue = vec3(0.33,0.37,0.23) + audioShift * AUDIO_COLOR_SHIFT;
    return clamp(
        COLOR_BASE +
        COLOR_AMP*cos(6.28318*(baseHue*t + vec3(0.00,0.27,0.55))),
        0.0,1.0);
}

vec3 render(vec2 uv, float t, float audioLevel){
    // Multi-layer polar quilting of SDFs with soft radiance
    vec3 acc = vec3(0.0);
    float wsum = 0.0;
    float baseR = 0.35 + 0.1*sin(t*0.4) + 0.05*audioLevel;
    float audioShift = audioLevel * 2.0 - 1.0; // Map [0,1] to [-1,1]
    
    // LAYERS layers: rotate/scale/offset; <=128 iterations
    for(int i=0;i<LAYERS;i++){
        float fi = float(i);
        float ang = 0.25*fi + 0.18*t + audioLevel * 0.5;
        float sc  = 1.0 + 0.28*sin(0.7*fi + 0.11*t);
        vec2 p = rot2d(uv*sc, ang);
        
        // Two motifs
        float th = atan(p.y, p.x);
        float ro = length(p);
        float petals = 6.0 + 2.0*sin(0.13*t + fi*0.7) + audioLevel * 4.0;
        float dRose = ro - (baseR + 0.12*sin(petals*th + 0.9*sin(0.33*t+fi)));
        float dRing = abs(sdCircle(p - 0.22*vec2(sin(0.8*t+fi), cos(0.9*t+1.2*fi)), 0.28 + 0.06*sin(0.5*t+fi))) - 0.02;
        float dBox  = sdRoundedBox(p + 0.17*vec2(cos(0.6*t+fi*1.3), sin(0.7*t+fi)), vec2(0.18,0.11), 0.09);
        float dMotif = sminExp(abs(dRose), sminExp(abs(dRing), abs(dBox), 6.0), 6.0);
        
        // Soft bloom contribution around the contour
        float band = exp(-12.0*abs(dMotif));
        float fringe = exp(-60.0*abs(abs(dRose)-0.02));
        float w = 0.5 + 0.8*sat2(1.0 - 3.0*abs(dMotif));
        vec3 pc = palette(0.18*fi + 0.47*t + 0.7*dRose, audioShift);
        vec3 lc = palette(0.21*fi - 0.36*t + 0.5*dBox, audioShift * 0.7);
        vec3 c = pc*(BLOOM_STRENGTH*band*(1.0 + audioLevel*AUDIO_BLOOM)) + lc*(FRINGE_STRENGTH*fringe*(1.0 + audioLevel*AUDIO_FRINGE));
        
        // radial attenuation for balance
        float att = exp(-1.6*dot(uv,uv)) * (0.7 + 0.3*sin(0.37*t + fi));
        acc += c * w * att;
        wsum += w * att;
    }
    acc /= max(wsum, 1e-4);
    
    // Light touch of pseudo-spec via gradient magnitude
    vec2 e = vec2(0.002,0.0);
    float d0 = sdCircle(uv, 0.6);
    float d1 = sdCircle(uv+e.xy, 0.6);
    float d2 = sdCircle(uv+e.yx, 0.6);
    float nd = length(vec2(d1-d0, d2-d0));
    acc += SPEC_STRENGTH*nd*SPEC_COLOR*(1.0 + audioLevel*AUDIO_SPEC);
    
    // Deeper darks and richer colors with audio boost
    acc = pow(acc * (BRIGHTNESS + audioLevel*AUDIO_BRIGHTNESS), vec3(CONTRAST_GAMMA));
    acc = mix(acc * DARK_CRUSH, acc, smoothstep(0.01, 0.25, length(acc)));
    
    return clamp(acc, 0.0, 1.0);
}

void main(){
    vec2 R = iResolution.xy;
    vec2 uv = (gl_FragCoord.xy - 0.5*R)/R.y;
    float t = iTime;

    // Get audio level from channel 0 - sample bass and treble regions
    float bass = texture(iChannel0, vec2(0.1, 0.5)).r;
    float treble = texture(iChannel0, vec2(0.8, 0.5)).r;
    float audioLevel = (bass + treble) * 0.5; // Combine bass and treble

    // Slow camera drift with audio influence
    uv = rot2d(uv + 0.04*sin(vec2(0.9,1.3)*t), 0.1*sin(0.2*t) + audioLevel*0.3);

    vec3 col = render(uv, t, audioLevel);
    fragColor = vec4(col, 1.0);
}