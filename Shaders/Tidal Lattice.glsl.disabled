#version 330 core

// Tidal Lattice - Audio-Reactive Symmetrical Grid Patterns
// Converted for OneOffRender system with multiple color palettes

uniform float iTime;
uniform vec2 iResolution;
uniform sampler2D iChannel0;

out vec4 fragColor;

void main() {
    // Screen coordinates to UV with Y-flip for correct orientation
    vec2 fragCoord = vec2(gl_FragCoord.x, iResolution.y - gl_FragCoord.y);
    vec2 r = iResolution.xy;
    vec2 uv = (fragCoord - 0.5 * r) / r.y;
    float t = iTime * 0.5;

    // Sample audio from Channel0
    float bass = texture(iChannel0, vec2(0.02, 0.0)).x;      // Low frequencies
    float mid = texture(iChannel0, vec2(0.1, 0.0)).x;       // Mid frequencies
    float treble = texture(iChannel0, vec2(0.3, 0.0)).x;    // High frequencies
    float overall = texture(iChannel0, vec2(0.0, 0.0)).x;   // Overall amplitude
    
    // Audio-reactive parameters
    float audioTime = t + bass * 2.0;
    float audioScale = 1.0 + overall * 0.5;
    float audioRotation = mid * 3.14159;
    
    // Palette switching - changes every 5-8 seconds, faster with audio intensity
    float paletteTime = t * (0.15 + overall * 0.1);
    int paletteIndex = int(mod(paletteTime, 6.0)); // 6 different palettes
    
    // Start with dark background - color shifts with palette changes
    vec3 backgroundColor = vec3(0.05, 0.02, 0.08);
    if (paletteIndex == 1) backgroundColor = vec3(0.02, 0.08, 0.05); // Dark green tint
    else if (paletteIndex == 2) backgroundColor = vec3(0.08, 0.05, 0.02); // Dark orange tint
    else if (paletteIndex == 3) backgroundColor = vec3(0.05, 0.08, 0.02); // Dark lime tint
    else if (paletteIndex == 4) backgroundColor = vec3(0.02, 0.05, 0.08); // Dark blue tint
    else if (paletteIndex == 5) backgroundColor = vec3(0.08, 0.02, 0.05); // Dark magenta tint
    
    vec3 col = backgroundColor;
    
    for (float z = 1.0; z < 8.0; z++) {
        // Create 4-fold symmetry by processing 4 quadrants
        vec2 p = abs(uv); // Mirror both axes for symmetry
        
        // Audio-reactive movement with symmetry preservation
        p += vec2(sin(audioTime * 0.7 + z), cos(audioTime * 0.6 + z)) * (0.2 + bass * 0.1);
        
        // Audio-reactive rotation matrix with symmetry
        float rotAngle = audioTime * 0.1 + z + audioRotation;
        p *= mat2(cos(rotAngle), -sin(rotAngle), sin(rotAngle), cos(rotAngle));
        
        // Audio-reactive grid frequency
        float gridFreq = 8.0 + treble * 4.0;
        float grid = abs(sin(p.x * gridFreq) + cos(p.y * gridFreq));
        
        // Audio-reactive fade and intensity
        float fade = exp(-z * (0.3 - overall * 0.15)) * audioScale;
        
        // Dynamic color palettes that change over time
        vec3 baseColor;
        float colorShift = z * 0.8 + audioTime * 0.5;
        
        // Choose palette based on time and audio intensity
        if (paletteIndex == 0) {
            // Ocean palette: blues, cyans, teals
            baseColor = vec3(
                0.1 + 0.3 * sin(colorShift * 0.8 + bass * 2.0),
                0.4 + 0.4 * sin(colorShift * 1.2 + mid * 3.0),
                0.7 + 0.3 * sin(colorShift + treble * 2.0)
            );
        } else if (paletteIndex == 1) {
            // Forest palette: greens, yellows, earth tones
            baseColor = vec3(
                0.3 + 0.4 * sin(colorShift * 1.1 + treble * 2.0),
                0.6 + 0.4 * sin(colorShift + bass * 3.0),
                0.2 + 0.3 * sin(colorShift * 0.7 + mid * 2.0)
            );
        } else if (paletteIndex == 2) {
            // Sunset palette: oranges, reds, purples
            baseColor = vec3(
                0.8 + 0.2 * sin(colorShift + bass * 4.0),
                0.4 + 0.3 * sin(colorShift * 1.3 + mid * 2.0),
                0.3 + 0.4 * sin(colorShift * 0.9 + treble * 3.0)
            );
        } else if (paletteIndex == 3) {
            // Electric palette: bright greens, yellows, whites
            baseColor = vec3(
                0.4 + 0.5 * sin(colorShift * 0.9 + treble * 3.0),
                0.8 + 0.2 * sin(colorShift + bass * 4.0),
                0.2 + 0.3 * sin(colorShift * 1.4 + mid * 2.0)
            );
        } else if (paletteIndex == 4) {
            // Ice palette: cool blues, whites, cyans
            baseColor = vec3(
                0.6 + 0.3 * sin(colorShift * 0.8 + mid * 2.0),
                0.7 + 0.3 * sin(colorShift * 1.1 + treble * 3.0),
                0.9 + 0.1 * sin(colorShift + bass * 2.0)
            );
        } else {
            // Cosmic palette: purples, magentas, deep blues
            baseColor = vec3(
                0.6 + 0.4 * sin(colorShift + bass * 3.0),
                0.3 + 0.3 * sin(colorShift * 1.5 + mid * 2.0),
                0.8 + 0.2 * sin(colorShift * 0.8 + treble * 4.0)
            );
        }
        
        // Add layer with additive blending (builds up colors instead of washing out to white)
        float intensity = fade / (grid * (2.0 + overall) + 0.5);
        col += baseColor * intensity * 0.3; // Reduced intensity to prevent over-saturation
    }
    
    // Audio-reactive color enhancement instead of just brightness
    col *= (0.8 + overall * 0.4);
    
    // Audio-reactive color saturation boost
    float saturation = 1.2 + bass * 0.5 + treble * 0.3;
    col = mix(vec3(dot(col, vec3(0.299, 0.587, 0.114))), col, saturation);
    
    // Subtle pulse effect that affects color temperature instead of brightness
    float pulse = sin(t * 8.0) * bass * 0.3;
    col.r += pulse * 0.1;
    col.b -= pulse * 0.05;
    
    fragColor = vec4(col, 1.0);
}