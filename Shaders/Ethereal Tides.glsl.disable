#version 330 core

/*
Ethereal Tides â€” flowing interference and velvet currents
Influences acknowledged: 
exploration spirit from BigWings/Flopine, structural sensitivity from Ferris, and playful motion echoes of Soerbgames.       
Original fluid mosaic using curl-like domain flow, ridged textures, and meditative chroma.
*/

uniform float iTime;
uniform vec2 iResolution;
uniform sampler2D iChannel0;  // Audio texture

out vec4 fragColor;

// ===== TWEAKABLE VARIABLES =====
#define FLOW_SCALE1 1.2  
#define FLOW_SCALE2 2.7  
#define FLOW_SPEED1 0.05 
#define FLOW_SPEED2 0.03 
#define FLOW_STRENGTH 0.65
#define CURL_STRENGTH1 0.60
#define CURL_STRENGTH2 0.40

#define FBM_OCTAVES 5    
#define RIDGE_SCALE1 2.0 
#define RIDGE_SCALE2 3.5 
#define RIDGE_SPEED1 0.11
#define RIDGE_SPEED2 0.07
#define RIDGE_STRENGTH 0.65

#define RIBBON_FREQ 7.0  
#define RIBBON_RADIAL 2.5
#define RIBBON_SPEED 0.8 
#define RIBBON_STRENGTH 0.35

#define BASE_BRIGHTNESS 0.55
#define GLOW_BRIGHTNESS 0.75
#define DEPTH_FALLOFF 0.9
#define CONTRAST_POW 1.2 

#define AUDIO_FLOW_MULT 0.8
#define AUDIO_HUE_MULT 1.5
#define AUDIO_BRIGHTNESS_MULT 0.6
#define AUDIO_RIBBON_MULT 1.2
#define AUDIO_SPEED_MULT 0.5
// ===============================

float hash21(vec2 p){    
    p = fract(p*vec2(123.34, 456.21));
    p += dot(p, p+45.32);    
    return fract(p.x*p.y);
}

float noise(vec2 p){     
    vec2 i = floor(p), f = fract(p);
    vec2 u = f*f*(3.0-2.0*f);
    float a = hash21(i); 
    float b = hash21(i+vec2(1.0,0.0));
    float c = hash21(i+vec2(0.0,1.0));
    float d = hash21(i+vec2(1.0,1.0));
    return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);  
}

float fbm(vec2 p){       
    float s = 0.0, a = 0.5;
    mat2 m = mat2(0.8,-0.6,0.6,0.8);
    for(int i=0;i<FBM_OCTAVES;i++){
        s += a*noise(p); 
        p = m*p*2.0;
        a *= 0.5;        
    }
    return s;
}

vec2 curl2D(vec2 p){     
    float e = 0.0015;    
    float n1 = fbm(p + vec2(0.0));
    float n2 = fbm(p + vec2(5.2,1.3));
    float dx1 = (fbm(p+vec2(e,0.0)) - fbm(p-vec2(e,0.0)))/(2.0*e);
    float dy1 = (fbm(p+vec2(0.0,e)) - fbm(p-vec2(0.0,e)))/(2.0*e);
    float dx2 = (fbm(p+vec2(e,0.0)+vec2(5.2,1.3)) - fbm(p-vec2(e,0.0)+vec2(5.2,1.3)))/(2.0*e);      
    float dy2 = (fbm(p+vec2(0.0,e)+vec2(5.2,1.3)) - fbm(p-vec2(0.0,e)+vec2(5.2,1.3)))/(2.0*e);      
    vec2 g = vec2(dx1+dx2, dy1+dy2);
    return vec2(g.y, -g.x) * 0.8;
}

vec3 palette(float t, float audioShift){
    // Smooth, vibrant but balanced palette with audio hue shifting        
    vec3 a = vec3(0.55, 0.45, 0.65);
    vec3 b = vec3(0.45, 0.35, 0.40);
    vec3 c = vec3(1.00, 0.90, 0.75);
    vec3 d = vec3(0.00, 0.33, 0.67) + audioShift * vec3(0.3, 0.2, 0.4);    
    return a + b*cos(6.28318*(c*t + d));
}

float satf(float x){ return clamp(x, 0.0, 1.0); } 

void main(){
    vec2 R = iResolution.xy;
    vec2 uv = (gl_FragCoord.xy - 0.5*R)/max(R.y, 1.0);  
    float t = iTime;     

    // Get audio level from channel 0 - sample bass and treble regions
    float bass = texture(iChannel0, vec2(0.1, 0.5)).r;
    float treble = texture(iChannel0, vec2(0.8, 0.5)).r;
    float audioLevel = (bass + treble) * 0.5; // Combine bass and treble
    float audioShift = (audioLevel - 0.5) * AUDIO_HUE_MULT;
    float audioFlow = audioLevel * AUDIO_FLOW_MULT;
    float audioSpeed = audioLevel * AUDIO_SPEED_MULT;

    // Flow field with audio reactivity
    vec2 p0 = uv * FLOW_SCALE1;
    vec2 flow = CURL_STRENGTH1 * curl2D(p0 * FLOW_SCALE1 + (FLOW_SPEED1 + audioSpeed) * t) +        
                CURL_STRENGTH2 * curl2D(p0 * FLOW_SCALE2 - (FLOW_SPEED2 + audioSpeed * 0.5) * t);   
    vec2 p = p0 + (FLOW_STRENGTH + audioFlow) * flow;

    // Ridged layers influenced by flow and audio 
    float h1 = fbm(p * RIDGE_SCALE1 + (RIDGE_SPEED1 + audioSpeed) * t);    
    float h2 = fbm(p * RIDGE_SCALE2 - (RIDGE_SPEED2 + audioSpeed * 0.7) * t + 3.0 * h1);
    float ridge = 1.0 - abs(2.0 * h2 - 1.0);      

    // Interference ribbons with audio modulation 
    float ang = atan(p.y, p.x);
    float r = length(p); 
    float audioRibbon = audioLevel * AUDIO_RIBBON_MULT;
    float rib = 0.5 + 0.5 * sin((RIBBON_FREQ + audioRibbon) * ang + RIBBON_RADIAL * r - (RIBBON_SPEED + audioSpeed) * t + 4.0 * h1);
    float field = RIDGE_STRENGTH * ridge + RIBBON_STRENGTH * rib;

    // Soft depth and vignette with audio brightness
    float depth = satf(1.0 - DEPTH_FALLOFF * length(uv));
    float glow = satf(0.5 + 0.8 * field) * depth * (1.0 + audioLevel * AUDIO_BRIGHTNESS_MULT);      

    // Hue drift with audio influence (removed mouse dependency)
    float hueKey = satf(0.5 + 0.5 * sin(0.2 * t + 4.0 * field + audioShift));        

    vec3 base = palette(0.15 + 0.25 * hueKey + 0.05 * sin(t * 0.13), audioShift);
    vec3 accent = palette(0.55 + 0.35 * hueKey + 0.07 * cos(t * 0.17), audioShift * 0.7);
    vec3 col = mix(base, accent, satf(glow));     

    // Contrast shaping and balanced vibrance with audio enhancement       
    col *= BASE_BRIGHTNESS + GLOW_BRIGHTNESS * pow(glow, CONTRAST_POW);    
    col = clamp(col, 0.0, 1.0);

    fragColor = vec4(col, 1.0);
}
