<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skybox Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
        }
        #controls h3 {
            margin-top: 0;
        }
        #controls label {
            display: block;
            margin: 10px 0 5px 0;
        }
        #controls input[type="file"] {
            margin-bottom: 10px;
        }
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="controls">
        <h3>Skybox Viewer</h3>
        <label>Right (px): <input type="file" id="px" accept="image/*"></label>
        <label>Left (nx): <input type="file" id="nx" accept="image/*"></label>
        <label>Top (py): <input type="file" id="py" accept="image/*"></label>
        <label>Bottom (ny): <input type="file" id="ny" accept="image/*"></label>
        <label>Front (pz): <input type="file" id="pz" accept="image/*"></label>
        <label>Back (nz): <input type="file" id="nz" accept="image/*"></label>
    </div>

    <div id="info">
        Drag to rotate camera | Scroll to zoom
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL not supported');
        }

        // Vertex shader
        const vertexShaderSource = `
            attribute vec3 aPosition;
            uniform mat4 uProjection;
            uniform mat4 uView;
            varying vec3 vTexCoord;
            
            void main() {
                vTexCoord = aPosition;
                vec4 pos = uProjection * uView * vec4(aPosition, 1.0);
                gl_Position = pos.xyww; // Skybox trick: set z = w so depth is always 1.0
            }
        `;

        // Fragment shader
        const fragmentShaderSource = `
            precision mediump float;
            uniform samplerCube uSkybox;
            varying vec3 vTexCoord;
            
            void main() {
                gl_FragColor = textureCube(uSkybox, vTexCoord);
            }
        `;

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Skybox cube vertices
        const vertices = new Float32Array([
            // Positions (cube centered at origin)
            -1, -1, -1,  1, -1, -1,  1,  1, -1, -1,  1, -1, // back
            -1, -1,  1,  1, -1,  1,  1,  1,  1, -1,  1,  1, // front
            -1, -1, -1, -1, -1,  1, -1,  1,  1, -1,  1, -1, // left
             1, -1, -1,  1, -1,  1,  1,  1,  1,  1,  1, -1, // right
            -1,  1, -1,  1,  1, -1,  1,  1,  1, -1,  1,  1, // top
            -1, -1, -1,  1, -1, -1,  1, -1,  1, -1, -1,  1  // bottom
        ]);

        const indices = new Uint16Array([
            0,  1,  2,   0,  2,  3,  // back
            4,  5,  6,   4,  6,  7,  // front
            8,  9, 10,   8, 10, 11,  // left
           12, 13, 14,  12, 14, 15,  // right
           16, 17, 18,  16, 18, 19,  // top
           20, 21, 22,  20, 22, 23   // bottom
        ]);

        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        const aPosition = gl.getAttribLocation(program, 'aPosition');
        gl.enableVertexAttribArray(aPosition);
        gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

        // Uniforms
        const uProjection = gl.getUniformLocation(program, 'uProjection');
        const uView = gl.getUniformLocation(program, 'uView');
        const uSkybox = gl.getUniformLocation(program, 'uSkybox');

        // Camera
        let cameraYaw = 0;
        let cameraPitch = 0;
        let cameraDistance = 1;

        // Mouse controls
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastX;
                const deltaY = e.clientY - lastY;
                cameraYaw += deltaX * 0.005;
                cameraPitch += deltaY * 0.005;
                cameraPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraPitch));
                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance *= (1 + e.deltaY * 0.001);
            cameraDistance = Math.max(0.1, Math.min(10, cameraDistance));
        });

        // Matrix functions
        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) / (near - far), -1,
                0, 0, (2 * far * near) / (near - far), 0
            ]);
        }

        function lookAt(yaw, pitch) {
            const cosPitch = Math.cos(pitch);
            const sinPitch = Math.sin(pitch);
            const cosYaw = Math.cos(yaw);
            const sinYaw = Math.sin(yaw);

            const forward = [
                cosPitch * sinYaw,
                sinPitch,
                cosPitch * cosYaw
            ];

            const right = [
                cosYaw,
                0,
                -sinYaw
            ];

            const up = [
                -sinPitch * sinYaw,
                cosPitch,
                -sinPitch * cosYaw
            ];

            return new Float32Array([
                right[0], up[0], -forward[0], 0,
                right[1], up[1], -forward[1], 0,
                right[2], up[2], -forward[2], 0,
                0, 0, 0, 1
            ]);
        }

        // Load cubemap
        const cubemapTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubemapTexture);

        const faceTargets = [
            gl.TEXTURE_CUBE_MAP_POSITIVE_X, // px (right)
            gl.TEXTURE_CUBE_MAP_NEGATIVE_X, // nx (left)
            gl.TEXTURE_CUBE_MAP_POSITIVE_Y, // py (top)
            gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, // ny (bottom)
            gl.TEXTURE_CUBE_MAP_POSITIVE_Z, // pz (front)
            gl.TEXTURE_CUBE_MAP_NEGATIVE_Z  // nz (back)
        ];

        const faceIds = ['px', 'nx', 'py', 'ny', 'pz', 'nz'];
        const loadedFaces = {};

        // Initialize with placeholder
        faceTargets.forEach((target) => {
            gl.texImage2D(target, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                new Uint8Array([128, 128, 128, 255]));
        });

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        // File input handlers
        faceIds.forEach((faceId, index) => {
            document.getElementById(faceId).addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubemapTexture);
                            gl.texImage2D(faceTargets[index], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                            loadedFaces[faceId] = true;
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });
        });

        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Render loop
        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);

            const aspect = canvas.width / canvas.height;
            const projectionMatrix = perspective(Math.PI / 3, aspect, 0.1, 100);
            const viewMatrix = lookAt(cameraYaw, cameraPitch);

            gl.uniformMatrix4fv(uProjection, false, projectionMatrix);
            gl.uniformMatrix4fv(uView, false, viewMatrix);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubemapTexture);
            gl.uniform1i(uSkybox, 0);

            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>

